--- assembler/src/debruijn/graph_simplification.hpp
+++ assembler/src/debruijn/graph_simplification.hpp
@@ -16,43 +16,24 @@
 #include "standard_base.hpp"
 #include "config_struct.hpp"
 #include "debruijn_graph.hpp"
-#include "stats/debruijn_stats.hpp"
+#include "debruijn_stats.hpp"
 
-#include "omni/visualization/graph_colorer.hpp"
 #include "omni/omni_utils.hpp"
 #include "omni/omni_tools.hpp"
 #include "omni/tip_clipper.hpp"
 #include "omni/bulge_remover.hpp"
 #include "omni/complex_bulge_remover.hpp"
 #include "omni/erroneous_connection_remover.hpp"
-#include "omni/relative_coverage_remover.hpp"
 #include "omni/mf_ec_remover.hpp"
 #include "utils.hpp"
 
 #include "detail_coverage.hpp"
 #include "graph_read_correction.hpp"
-#include "ec_threshold_finder.hpp"
-#include "detail_coverage.hpp"
-
-#include "stats/chimera_stats.hpp"
 
 namespace debruijn_graph {
 
-//todo move to visualization
-template<class graph_pack>
-shared_ptr<omnigraph::visualization::GraphColorer<typename graph_pack::graph_t>> DefaultGPColorer(
-        const graph_pack& gp) {
-    typedef typename graph_pack::graph_t Graph;
-    typedef typename Graph::EdgeId EdgeId;
-
-    auto mapper = MapperInstance(gp);
-    auto path1 = mapper->MapSequence(gp.genome).path();
-    auto path2 = mapper->MapSequence(!gp.genome).path();
-    return omnigraph::visualization::DefaultColorer(gp.g, path1, path2);
-}
-
 class LengthThresholdFinder {
-public:
+  public:
     static size_t MaxTipLength(size_t read_length, size_t k, double coeff) {
         return std::max((size_t) math::round((double)std::min(k, read_length / 2) * coeff),
                         read_length);
@@ -576,74 +551,72 @@
     return res;
 }
 
-template<class gp_t>
+template<class Graph>
 bool FinalRemoveErroneousEdges(
-    gp_t &gp,
-    boost::function<void(typename Graph::EdgeId)> removal_handler,
-    double determined_coverage_threshold,
-    size_t iteration) {
-
-//    gp.ClearQuality();
-//    gp.FillQuality();
-//    auto colorer = debruijn_graph::DefaultGPColorer(gp);
-//    omnigraph::DefaultLabeler<typename gp_t::graph_t> labeler(gp.g, gp.edge_pos);
-//    QualityEdgeLocalityPrintingRH<Graph> qual_removal_handler(gp.g, gp.edge_qual, labeler, colorer,
-//                                   cfg::get().output_dir + "pictures/colored_edges_deleted/");
-//
-//    //positive quality edges removed (folder colored_edges_deleted)
-//    boost::function<void(EdgeId)> qual_removal_handler_f = boost::bind(
-//            //            &QualityLoggingRemovalHandler<Graph>::HandleDelete,
-//            &QualityEdgeLocalityPrintingRH<Graph>::HandleDelete,
-//            boost::ref(qual_removal_handler), _1);
-//
-//    boost::function<void(set<EdgeId>)> set_removal_handler_f = boost::bind(
-//                &omnigraph::simplification::SingleEdgeAdapter<set<EdgeId>>, _1, qual_removal_handler_f);
-//
-    boost::function<void(set<EdgeId>)> set_removal_handler_f = boost::bind(
-                &omnigraph::simplification::SingleEdgeAdapter<set<EdgeId>>, _1, removal_handler);
-
-    bool changed = RemoveRelativelyLowCoverageComponents(gp.g, gp.flanking_cov,
-                                          cfg::get().simp.rcc, determined_coverage_threshold,
-                                          cfg::get().ds.RL(), set_removal_handler_f);
+    Graph &g, boost::function<void(typename Graph::EdgeId)> removal_handler,
+    double determined_coverage_threshold, size_t iteration) {
+
+    bool changed = RemoveRelativelyLowCoverageEdges(
+        g, cfg::get().simp.rec, removal_handler,
+        determined_coverage_threshold);
 
     if (cfg::get().simp.topology_simplif_enabled && cfg::get().main_iteration) {
-        changed |= AllTopology(gp.g, removal_handler, iteration);
-        changed |= MaxFlowRemoveErroneousEdges(gp.g, cfg::get().simp.mfec,
+        changed |= AllTopology(g, removal_handler, iteration);
+        changed |= MaxFlowRemoveErroneousEdges(g, cfg::get().simp.mfec,
                                                removal_handler);
     }
+
     return changed;
 }
 
 inline
 void PreSimplification(conj_graph_pack& gp,
                        boost::function<void(EdgeId)> removal_handler,
+                       detail_info_printer & /*printer*/, size_t /*iteration_count*/,
                        double determined_coverage_threshold) {
     INFO("PROCEDURE == Presimplification");
-    RemoveSelfConjugateEdges(gp.g, 100, 1., removal_handler);
-
     INFO("Early tip clipping");
-
     ClipTipsWithProjection(gp, cfg::get().simp.tc,
                            cfg::get().graph_read_corr.enable, cfg::get().ds.RL(),
                            determined_coverage_threshold, removal_handler);
 
-    INFO("Isolated edge remover");
-    size_t max_length = std::max(cfg::get().ds.RL(), cfg::get().simp.ier.max_length_any_cov);
-    INFO("All edges of length smaller than " << max_length << " will be removed");
-    IsolatedEdgeRemover<Graph>(gp.g, cfg::get().simp.ier.max_length,
-                               cfg::get().simp.ier.max_coverage, max_length)
-            .RemoveIsolatedEdges();
-
     INFO("Early bulge removal");
     RemoveBulges(gp.g, cfg::get().simp.br, 0, removal_handler, gp.g.k() + 1);
 }
 
+inline
+void SimplificationCycle(conj_graph_pack& gp,
+                         boost::function<void(EdgeId)> removal_handler,
+                         detail_info_printer &printer, size_t iteration_count,
+                         size_t iteration, double max_coverage) {
+    INFO("PROCEDURE == Simplification cycle, iteration " << (iteration + 1));
+
+    DEBUG(iteration << " TipClipping");
+    ClipTipsWithProjection(gp, cfg::get().simp.tc,
+                           cfg::get().graph_read_corr.enable, cfg::get().ds.RL(),
+                           max_coverage, removal_handler);
+    DEBUG(iteration << " TipClipping stats");
+    printer(ipp_tip_clipping, str(format("_%d") % iteration));
+
+    DEBUG(iteration << " BulgeRemoval");
+    RemoveBulges(gp.g, cfg::get().simp.br, 0, removal_handler);
+    DEBUG(iteration << " BulgeRemoval stats");
+    printer(ipp_bulge_removal, str(format("_%d") % iteration));
+
+    DEBUG(iteration << " ErroneousConnectionsRemoval");
+    RemoveLowCoverageEdges(gp.g, cfg::get().simp.ec, removal_handler,
+                           cfg::get().ds.RL(), max_coverage, iteration_count,
+                           iteration);
+    DEBUG(iteration << " ErroneousConnectionsRemoval stats");
+    printer(ipp_err_con_removal, str(format("_%d") % iteration));
+
+}
 
 inline
 void PostSimplification(conj_graph_pack& gp,
-                        boost::function<void(EdgeId)> &removal_handler,
+                        boost::function<void(EdgeId)> removal_handler,
+                        detail_info_printer & /*printer*/,
                         double determined_coverage_threshold) {
-
     INFO("PROCEDURE == Post simplification");
     size_t iteration = 0;
     bool enable_flag = true;
